{"version":3,"file":"timeline.js","sourceRoot":"","sources":["../../src/timeline.ts"],"names":[],"mappings":";;;AAAA,8DAUoC;AACpC,yDAAqD;AAErD;IAAA;QACE,UAAK,GAA6B,EAAE,CAAC;QACrC,kDAAkD;QAClD,aAAQ,GAAG,KAAK,CAAC;QACjB,4DAA4D;QAC5D,yFAAyF;QACzF,YAAO,GAAa,EAAE,CAAC;IAgGzB,CAAC;IA9FO,2BAAQ,GAAd,UAAe,MAAc,EAAE,MAAc;;;;4BAC3C,qBAAM,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAA;;wBAA1B,SAA0B,CAAC;wBAC3B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;;;;;KAC3B;IAED,6BAAU,GAAV,UAAW,UAAkB;QAC3B,IAAI,CAAC,OAAO,CAAC,MAAM,CACjB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,IAAI,KAAK,UAAU,EAA1B,CAA0B,CAAC,EAC9D,CAAC,CACF,CAAC;QACF,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,wBAAK,GAAL;QACE,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;IACpB,CAAC;IAED,uBAAI,GAAJ,UAAK,KAAY;QAAjB,iBAKC;QAJC,OAAO,IAAI,OAAO,CAAS,UAAC,OAAO;YACjC,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;YAClC,KAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;QACxB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,gCAAa,GAAb,UAAc,OAAe;QAA7B,iBAWC;QAVC,IAAI,IAAI,CAAC,QAAQ;YAAE,OAAO;QAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,UAAU,CAAC;YACT,KAAK,KAAI,CAAC,KAAK,CAAC,KAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC;gBACvC,KAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;gBACtB,IAAI,KAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;oBACzB,KAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;iBACvB;YACH,CAAC,CAAC,CAAC;QACL,CAAC,EAAE,OAAO,CAAC,CAAC;IACd,CAAC;IAEK,wBAAK,GAAX,UAAY,IAAwC;;;;;;;wBAClD,IAAI,CAAC,IAAI,EAAE;4BACT,sBAAO;yBACR;wBAEG,KAAA,eAAU,IAAI,IAAA,EAAb,KAAK,QAAA,CAAS;wBACb,KAAA,eAAc,IAAI,IAAA,EAAf,OAAO,QAAA,CAAS;wBAEnB,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAChC,UAAC,MAAc,IAA6B,OAAA,MAAM,CAAC,IAAI,KAAK,4BAAU,CAAC,MAAM,EAAjC,CAAiC,CAC9E,CAAC;;;;wBAEmB,WAAA,iBAAA,MAAM,CAAA;;;;wBAAhB,MAAM;wBACP,qBAAM,MAAM,CAAC,OAAO,sBAAM,KAAK,EAAG,EAAA;;wBAA1C,KAAK,GAAG,SAAkC,CAAC;;;;;;;;;;;;;;;;;wBAGvC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CACpC,UAAC,MAAc,IAAiC,OAAA,MAAM,CAAC,IAAI,KAAK,4BAAU,CAAC,UAAU,EAArC,CAAqC,CACtF,CAAC;;;;wBAEmB,eAAA,iBAAA,UAAU,CAAA;;;;wBAApB,MAAM;wBACP,qBAAM,MAAM,CAAC,OAAO,sBAAM,KAAK,EAAG,EAAA;;wBAA1C,KAAK,GAAG,SAAkC,CAAC;;;;;;;;;;;;;;;;;wBAGvC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CACrC,UAAC,MAAc,IAAkC,OAAA,MAAM,CAAC,IAAI,KAAK,4BAAU,CAAC,WAAW,EAAtC,CAAsC,CACxF,CAAC;wBAEI,mBAAmB,GAAG,WAAW,CAAC,GAAG,CAAC,UAAC,MAAM;4BACjD,IAAM,UAAU,wBAAQ,KAAK,CAAE,CAAC;4BAChC,OAAO,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,IAAA,4BAAW,EAAC,UAAU,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,EAArC,CAAqC,CAAC,CAAC;wBACxF,CAAC,CAAC,CAAC;wBAEH,KAAK,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC,UAAC,EAAQ;gCAAR,KAAA,qBAAQ,EAAP,MAAM,QAAA;4BACjD,OAAO,CAAC,MAAM,CAAC,CAAC;wBAClB,CAAC,CAAC,CAAC;wBAEH,sBAAO;;;;KACR;IAEK,wBAAK,GAAX;;;;;;;wBACQ,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;wBACzB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;wBAEhB,qBAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,UAAC,IAAI,IAAK,OAAA,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAhB,CAAgB,CAAC,CAAC,EAAA;;wBAAxD,SAAwD,CAAC;wBAEnD,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CACrC,UAAC,MAAc,IAAkC,OAAA,MAAM,CAAC,IAAI,KAAK,4BAAU,CAAC,WAAW,EAAtC,CAAsC,CACxF,CAAC;wBAEI,mBAAmB,GAAG,WAAW,CAAC,GAAG,CAAC,UAAC,MAAM;4BACjD,OAAO,MAAM,CAAC,KAAK,IAAI,MAAM,CAAC,KAAK,EAAE,CAAC;wBACxC,CAAC,CAAC,CAAC;wBAEH,qBAAM,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,EAAA;;wBAAtC,SAAsC,CAAC;;;;;KACxC;IACH,eAAC;AAAD,CAAC,AAtGD,IAsGC;AAtGY,4BAAQ","sourcesContent":["import {\n  BeforePlugin,\n  Config,\n  DestinationPlugin,\n  EnrichmentPlugin,\n  Event,\n  EventCallback,\n  Plugin,\n  PluginType,\n  Result,\n} from '@amplitude/analytics-types';\nimport { buildResult } from './utils/result-builder';\n\nexport class Timeline {\n  queue: [Event, EventCallback][] = [];\n  // Flag to guarantee one schedule apply is running\n  applying = false;\n  // Flag indicates whether timeline is ready to process event\n  // Events collected before timeline is ready will stay in the queue to be processed later\n  plugins: Plugin[] = [];\n\n  async register(plugin: Plugin, config: Config) {\n    await plugin.setup(config);\n    this.plugins.push(plugin);\n  }\n\n  deregister(pluginName: string) {\n    this.plugins.splice(\n      this.plugins.findIndex((plugin) => plugin.name === pluginName),\n      1,\n    );\n    return Promise.resolve();\n  }\n\n  reset() {\n    this.applying = false;\n    this.plugins = [];\n  }\n\n  push(event: Event) {\n    return new Promise<Result>((resolve) => {\n      this.queue.push([event, resolve]);\n      this.scheduleApply(0);\n    });\n  }\n\n  scheduleApply(timeout: number) {\n    if (this.applying) return;\n    this.applying = true;\n    setTimeout(() => {\n      void this.apply(this.queue.shift()).then(() => {\n        this.applying = false;\n        if (this.queue.length > 0) {\n          this.scheduleApply(0);\n        }\n      });\n    }, timeout);\n  }\n\n  async apply(item: [Event, EventCallback] | undefined) {\n    if (!item) {\n      return;\n    }\n\n    let [event] = item;\n    const [, resolve] = item;\n\n    const before = this.plugins.filter<BeforePlugin>(\n      (plugin: Plugin): plugin is BeforePlugin => plugin.type === PluginType.BEFORE,\n    );\n\n    for (const plugin of before) {\n      event = await plugin.execute({ ...event });\n    }\n\n    const enrichment = this.plugins.filter<EnrichmentPlugin>(\n      (plugin: Plugin): plugin is EnrichmentPlugin => plugin.type === PluginType.ENRICHMENT,\n    );\n\n    for (const plugin of enrichment) {\n      event = await plugin.execute({ ...event });\n    }\n\n    const destination = this.plugins.filter<DestinationPlugin>(\n      (plugin: Plugin): plugin is DestinationPlugin => plugin.type === PluginType.DESTINATION,\n    );\n\n    const executeDestinations = destination.map((plugin) => {\n      const eventClone = { ...event };\n      return plugin.execute(eventClone).catch((e) => buildResult(eventClone, 0, String(e)));\n    });\n\n    void Promise.all(executeDestinations).then(([result]) => {\n      resolve(result);\n    });\n\n    return;\n  }\n\n  async flush() {\n    const queue = this.queue;\n    this.queue = [];\n\n    await Promise.all(queue.map((item) => this.apply(item)));\n\n    const destination = this.plugins.filter<DestinationPlugin>(\n      (plugin: Plugin): plugin is DestinationPlugin => plugin.type === PluginType.DESTINATION,\n    );\n\n    const executeDestinations = destination.map((plugin) => {\n      return plugin.flush && plugin.flush();\n    });\n\n    await Promise.all(executeDestinations);\n  }\n}\n"]}